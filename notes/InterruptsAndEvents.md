# Interrupts And Events

## Programmers Model

The STM32F10xxx Cortex®-M3 processor is built around an exceptions and interrupts model.
`The Cortex-M3 processor supports interrupts and system exceptions. The processor and the Nested Vectored Interrupt Controller (NVIC) prioritize and handle all exceptions`.
An exception changes the normal flow of software control. `The processor uses handler mode to handle all exceptions except for reset`.`The NVIC registers control interrupt handling`.

## Exception Model

### Exception states

- Inactive
  The exception is not active and not pending.
- Pending
  The exception is waiting to be serviced by the processor.
  An interrupt request from a peripheral or from software can change the state of the corresponding interrupt to pending.
- Active
  An exception that is being serviced by the processor but has not completed.
  `Note: An exception handler can interrupt the execution of another exception handler. In this case both exceptions are in the active state.`
- Active and pending  
  The exception is being serviced by the processor and there is a pending exception from the same source.

### Exception types

- Reset
  Reset is invoked on power up or a warm reset. The exception model treats reset as a special form of exception. When reset is asserted, the operation of the processor stops, potentially at any point in an instruction. When reset is deasserted, execution restarts from the address provided by the reset entry in the vector table. Execution restarts as privileged execution in Thread mode.
- NMI
  A NonMaskable Interrupt (NMI) can be signalled by a peripheral or triggered by software. This is the highest priority exception other than reset. It is permanently enabled and has a fixed priority of -2. NMIs cannot be:
    • Masked or prevented from activation by any other exception
    • Preempted by any exception other than Reset.
- Hard fault
  A hard fault is an exception that occurs because of an error during exception processing, or because an exception cannot be managed by any other exception mechanism（异常处理机制）. Hard faults have a fixed priority of -1, meaning they have higher priority than any exception with configurable priority.
- Memory management fault
  A memory management fault is an exception that occurs because of a memory protection related fault. The fixed memory protection constraints determines this fault, for both instruction and data memory transactions. This fault is used to abort instruction accesses to Execute Never (XN) memory regions.（这个异常被用来去终止指令访问非执行内存区，即非法内存访问）
- Bus fault
  A bus fault is an exception that occurs because of a memory related fault for an instruction or data memory transaction. This might be from an error detected on a bus in the memory system.
- Usage fault
  A usage fault is an exception that occurs because of a fault related to instruction execution. This includes:
    • An undefined instruction
    • An illegal unaligned access
    • Invalid state on instruction execution
    • An error on exception return.
    The following can cause a usage fault when the core is configured to report them:
    • An unaligned address on word and halfword memory access
    • Division by zero
- SVCall
  A supervisor call (SVC) is an exception that is triggered by the SVC instruction. In an OS environment, applications can use SVC instructions to access OS kernel functions and device drivers.
- PendSV
  PendSV is an interrupt-driven request for system-level service. In an OS environment, use PendSV for context switching when no other exception is active.
- SysTick
  A SysTick exception is an exception the system timer generates when it reaches zero (当系统定时器达到0时,会触发中断产生这个异常).
  Software can also generate a SysTick exception. In an OS environment, the processor can use this exception as system tick.

#### External interrupts

- `Interrupt (IRQ)` (Exception number 16 to 67) (IRQ 0 to IRQ 67)
  `A interrupt, or IRQ, is an exception signalled by a peripheral, or generated by a software request. All interrupts are asynchronous to instruction execution. In the system, peripherals use interrupts to communicate with the processor`(使用该外部中断源可以执行对应的中断处理函数).

`Proporities of the different exceptions types on page 33 of the Cortex-M3 programming manual`.

`For an asynchronous exception, other than reset`, the processor can execute another instruction between when the exception is triggered and when the processor enters the exception handler.（对于除了复位外的异步异常，在异步异常被触发到处理器进入异常处理程序之际，处理器可以执行正在执行的另一个指令，当一个异步异常被触发时，处理器不会立即进入异常处理程序，而是可能会先执行另一个指令。这是因为处理器需要一些时间来响应异常，包括保存当前的上下文，设置新的程序计数器等。在这个过程中，处理器可能会执行下一个已经在流水线中的指令）

### Exception handlers (中断处理程序)

- Interrupt Service Routines (ISRs)
  Interrupts IRQ0 to IRQ67 are the exceptions handled by ISRs (外部中断源IRQx的中断处理交由ISRx执行).
- Fault handlers
  Hard fault, memory management fault, usage fault, bus fault are fault exceptions handled by the fault handlers (内部故障源的异常处理交由故障处理器).
- System handlers
  NMI, PendSV, SVCall SysTick, and the fault exceptions are all system exceptions that are handled by system handlers (内部系统异常的处理交由系统处理器).

### Vector table

`Vector table on page 35 of the Cortex-M3 programming manual`.

### Exception priorities

All exceptions have an associated priority,with:

- A lower priority value indicating a higher priority
- Configurable priorities for all exceptions except Reset, Hard fault, and NMI.

`If software does not configure any priorities, then all exceptions with a configurable priority have a priority of 0`. Refer to System handler priority register (SHPRx) and Interrupt priority register (NVIC_IPRx) for more information on exception priorities.

`Configurable priority values are in the range 0-15. This means that the Reset, Hard fault,
and NMI exceptions, with fixed negative priority values, always have higher priority than any
other exception`.
For example, assigning a higher priority value to IRQ[0] and a lower priority value to IRQ[1] means that IRQ[1] has higher priority than IRQ[0]. If both IRQ[1] and IRQ[0] are asserted, IRQ[1] is processed before IRQ[0].
If multiple pending exceptions have the same priority, the pending exception with the lowest exception number takes precedence.
For example, if both IRQ[0] and IRQ[1] are pending and have the same priority, then IRQ[0] is processed before IRQ[1].（这说明，当有多个同等优先级的中断待处理时，处理器会按照中断号的顺序进行处理）
When the processor is executing an exception handler, the exception handler is preempted if a higher priority exception occurs.（这说明，高优先级的异常可以打断正在执行的低优先级的异常处理程序）
If an exception occurs with the same priority as the exception being handled, the exception handler is not preempted, irrespective of the exception number. However, the status of the new interrupt changes to pending.（这说明，同等优先级的异常不会打断正在执行的异常处理程序，但是新的异常会被标记为待处理，等待当前的异常处理完成后再进行处理。）

### Interrupt priority grouping

To increase priority control in systems with interrupts, the NVIC supports priority grouping.
This divides each interrupt priority register entry into two fields（将每个中断优先级寄存器条目分为两个字段）:
    • An upper field that defines the group priority
    • A lower field that defines a subpriority within the group（定义组内子优先级）.
    （这说明，每个中断都有一个组优先级和一个子优先级，这两个优先级一起决定了中断的处理顺序）
Only the group priority determines preemption of interrupt exceptions（只有组优先级决定中断异常的抢占）.
When the processor is executing an interrupt exception handler, another interrupt with the same group priority as the interrupt being handled `does not preempt` the handler（这说明，只有当新的中断的组优先级高于正在处理的中断的组优先级时，新的中断才能抢占正在执行的中断处理程序）,If multiple pending interrupts have the same group priority, the subpriority field determines the order in which they are processed. If multiple pending interrupts have the same group
priority and subpriority, `the interrupt with the lowest IRQ number is processed first`（这说明，当有多个中断具有相同的组优先级时，处理器会根据中断的子优先级<先比较>和IRQ号<后比较>来决定处理顺序）.

For information about splitting the interrupt priority fields into group priority and subpriority, see `Application interrupt and reset control register (SCB_AIRCR)`.

### Exception entry and return

- Preemption
    When the processor is executing an exception handler, an exception can preempt the exception handler if its priority is higher than the priority of the exception being handled. When one exception preempts another, the exceptions are called nested exceptions（中断嵌套）.
- Return
  This occurs when the exception handler is completed, and:
    • There is no pending exception with sufficient priority（没有足够优先级的待处理异常） to be serviced
    • The completed exception handler was not handling a late-arriving exception（已完成的异常处理程序之前没有要处理迟到的异常）.
  The processor pops the stack and restores the processor state to the state it had before the interrupt occurred（回到中断发生前的状态）.
- Tail-chaining
  This mechanism speeds up exception servicing. On completion of an exception handler, if there is a pending exception that meets the requirements for exception entry, the stack pop is skipped（处理器跳过堆栈弹出操作）and control handling transfers to the new exception handler(执行新的异常处理程序).
- Late-arriving
  This mechanism speeds up preemption. If a higher priority exception occurs during state saving for a previous exception（在为之前的异常保存状态时,保存context）, the processor switches to handle the higher priority exception and initiates the vector fetch for that exception（这就是说，处理器会立即开始处理优先级更高的异常，而不是等待当前的异常处理完成）. State saving is not affected by late arrival because the state saved is the same for both exceptions. Therefore the state saving continues uninterrupted（这就是说，处理器会继续保存当前异常的状态，即使有新的更高优先级的异常发生）. The processor can accept a late arriving exception until the first instruction of the exception handler of the original exception enters the execute stage of the processor（这就是说，处理器可以在任何时候接受新的异常，只要它的优先级更高，并且当前的异常处理还没有开始执行，若开始执行，那就会进入中断嵌套）. On return from the exception handler of the late-arriving exception, the normal tail-chaining rules apply（这就是说，当处理完优先级更高的异常后，处理器会返回到原来的异常处理程序，继续执行未完成的部分）.

#### Exception entry

Exception entry occurs when there is a pending exception with sufficient priority and either:
    • The processor is in Thread mode
    • The new exception is of higher priority than the exception being handled, in which case the new exception preempts the original exception.

When one exception preempts another, the exceptions are nested.

`Sufficient priority` means the exception has more priority than any limits set by the mask registers（高于掩码寄存器设定的任何限制）. An exception with less priority than this is pending but is not handled by the processor（优先级低于此的异常处于待处理状态，但处理器不会处理）.

When the processor takes an exception, unless the exception is a tail-chained or a late-
arriving exception, the processor pushes information onto the current stack. This operation
is referred as stacking and the structure of eight data words is referred as stack frame（堆栈帧）. The stack frame contains the following information:

• R0-R3, R12
• Return address
• PSR
• LR.

Immediately after stacking, the stack pointer indicates the lowest address in the stack frame.
Unless stack alignment（堆栈对齐） is disabled, the stack frame is aligned to a double-word address. If the STKALIGN bit of the Configuration Control Register (CCR) is set to 1, stack align adjustment is performed during stacking.

The stack frame includes the return address. This is the address of the next instruction in the interrupted program. This value is restored to the PC at exception return so that the interrupted program resumes.

In parallel to the stacking operation, the processor performs a vector fetch that reads the exception handler start address from the vector table. When stacking is complete, the processor starts executing the exception handler. At the same time, the processor writes an EXC_RETURN value to the LR. This indicates which stack pointer corresponds to the stack frame and what operation mode the was processor was in before the entry occurred.

If no higher priority exception occurs during exception entry, the processor starts executing
the exception handler and automatically changes the status of the corresponding pending
interrupt to active.

If another higher priority exception occurs during exception entry, the processor starts executing the exception handler for this exception and does not change the pending status of the earlier exception. This is the late arrival case.

#### Exception return

Exception return occurs when the processor is in Handler mode and executes one of the following instructions to load the EXC_RETURN value into the PC:

• A POP instruction that includes the PC
• A BX instruction with any register.
• An LDR or LDM instruction with the PC as the destination

EXC_RETURN is the value loaded into the LR on exception entry. The exception
mechanism relies on this value to detect when the processor has completed an exception handler. The lowest four bits of this value provide information on the return stack and processor mode.
Table  17 on page 39  shows the EXC_RETURN[3:0] values with a description of the exception return behavior. The processor sets EXC_RETURN bits[31:4] to 0xFFFFFFF. When this value is loaded into the PC it indicates to the processor that the exception is complete, and the processor initiates the exception return sequence.

### Summary

When an exception occurs, the processor performs the following steps:
    • Saves the current state of the processor in the stack
    • Loads the exception vector table address into the PC
    • Starts execution of the exception handler
    • Changes the status of the exception from pending to active.

## Nested Vector Interrupt Controller (NVIC)

NVIC（嵌套向量中断控制器）是ARM Cortex-M系列微控制器的一部分，用于管理和处理中断，其与处理器内核的接口紧密相连，可以实现低延迟和高效的中断处理。NVIC管理着包括内核异常（内部中断），外部中断等所有中断。由NVIC决定哪个中断处理程序可交给CPU来执行。
每一个外部中断都可以被使能或者禁止，并且可以被设置为挂起状态或者清除状态。处理器的中断可以电平的形式，也可以是脉冲形式，这样中断控制器就可以处理任何中断源。
16个IO的中断与PVD(电源电压检测)，RTC(实时时钟)，USB，以太网检测这20个外部中断会通过EXTI来控制，然后交给NVIC。其他中断都是直接交给NVIC来处理。

### Features

- 68 (not including the sixteen Cortex®-M3 interrupt lines) interrupt lines
- 16 programmable priority levels (4 bits of interrupt priority are used)
- Low-latency exception and interrupt handling
- Power management control
- Implementation of System Control registers

This section describes the Nested Vectored Interrupt Controller (NVIC) and the registers it uses. The NVIC supports:
• up to 81 interrupts (depends on the STM32 device type, refer to the datasheets)
• A programmable priority level of 0-15 for each interrupt. A higher level corresponds to a lower priority, so level 0 is the highest interrupt priority
• Level and pulse detection of interrupt signals
• Dynamic reprioritization of interrupts
• Grouping of priority values into group priority and subpriority fields
• Interrupt tail-chaining
• An external Non-maskable interrupt (NMI)

The NVIC and the processor core interface are closely coupled, which enables low latency
interrupt processing and efficient processing of late arriving interrupts.
`All interrupts including the core exceptions are managed by the NVIC`. For more information
on exceptions and NVIC programming, refer to STM32F10xxx Cortex®-M3 programming manual.

## External interrupt/event controller (EXTI)

The external interrupt/event controller consists of up to 20 edge detectors in connectivity line devices, or 19 edge detectors in other devices for generating event/interrupt requests.
Each input line can be independently configured to select the type (event or interrupt) and the corresponding trigger event (rising or falling or both). Each line can also masked independently. A pending register maintains the status line of the interrupt requests.

### Main features

The EXTI controller main features are the following:

- Independent trigger and mask on each interrupt/event line
- Dedicated status bit for each interrupt line
- Generation of up to 20 software event/interrupt requests
- Detection of external signal with pulse width lower than APB2 clock period. Refer to the
electrical characteristics section of the datasheet for details on this parameter

### Block diagram

Refer to the block diagram in the STM32F10xxx reference manual.

### Wakeup event management

The STM32F10xxx is able to handle external or internal events in order to wake up the core (WFE)（STM32F10xxx处理外部或内部事件以及唤醒核心）. The wakeup event can be generated either by:

- enabling an interrupt in the peripheral control register but not in the NVIC, and enabling
the SEVONPEND bit in the Cortex®-M3 System Control register. When the MCU resumes from WFE, the peripheral interrupt pending bit and the peripheral NVIC IRQ channel pending bit (in the NVIC interrupt clear pending register) have to be cleared.
- or configuring an external or internal EXTI line in event mode. When the CPU resumes from WFE, it is not necessary to clear the peripheral interrupt pending bit or the NVIC
IRQ channel pending bit as the pending bit corresponding to the event line is not set.

In connectivity line devices, Ethernet wakeup events also have the WFE wakeup capability.

### Functional description

To generate the interrupt, the interrupt line should be configured and enabled. This is done by programming the two trigger registers with the desired edge detection and by enabling the interrupt request by writing a ‘1’ to the corresponding bit in the interrupt mask register.
When the selected edge occurs on the external interrupt line, an interrupt request is
generated. The pending bit corresponding to the interrupt line is also set. `This request is
reset by writing a ‘1’ in the pending register`.
To generate the event, the event line should be configured and enabled. This is done by programming the two trigger registers with the desired edge detection and by enabling the event request by writing a ‘1’ to the corresponding bit in the event mask register. When the selected edge occurs on the event line, an event pulse is generated. The pending bit corresponding to the event line is not set
An interrupt/event request can also be generated by software by writing a ‘1’ in the software interrupt/event register

### Hardware interrupt selection

To configure the 20 lines as interrupt sources, use the following procedure:

- Configure the mask bits of the 20 Interrupt lines (EXTI_IMR)
- Configure the Trigger Selection bits of the Interrupt lines (EXTI_RTSR and EXTI_FTSR)
- Configure the enable and mask bits that control the NVIC IRQ channel mapped to the External Interrupt Controller (EXTI) so that an interrupt coming from one of the 20 lines can be correctly acknowledged.

### Hardware event selection

To configure the 20 lines as event sources, use the following procedure:

- Configure the mask bits of the 20 Event lines (EXTI_EMR)
- Configure the Trigger Selection bits of the Event lines (EXTI_RTSR and EXTI_FTSR)

### Software interrupt/event selection

The 20 lines can be configured as software interrupt/event lines. The following is the 
procedure to generate a software interrupt.

- Configure the mask bits of the 20 Interrupt/Event lines (EXTI_IMR, EXTI_EMR)
- Set the required bit of the software interrupt register (EXTI_SWIER)

### External interrupt/event line mapping

Refer to the external interrupt/event line mapping table on page 210 in the STM32F10xxx reference manual.
