#include "Driver_Key.h"
#include "Driver_LED.h"
#include "Delay.h"

/* 因为延时函数用到系统滴答定时器，实现用到中断，而这个中断的优先级最低没法打断别的中断，因此没法使用 */
// 粗延时函数，微秒
void delay_us(u16 time)
{
   u16 i = 0;
   while (time--)
   {
      i = 10; // 自己定义
      while (i--)
         ;
   }
}
// 毫秒级的延时
void delay_ms(u16 time)
{
   u16 i = 0;
   while (time--)
   {
      i = 12000;
      while (i--)
         ;
   }
}

/**
 * @description: 初始化按键.
 *  1. 给按键对应的io口设置工作模式: 下拉输入
 *  2. 配置复用为外部中断
 *  3. 配置外部中断控制器 EXTI
 *  4. 配置NVIC
 *
 *
 * GPIOF Pin10 外接一个按键KEY3，按键（KEY3）连接到 3.3V 电源。这意味着：
 * 按键松开时：GPIOF Pin10 悬空（未连接到任何电压）。
 * 按键按下时：GPIOF Pin10 连接到 3.3V，输入高电平。
 * 在这种情况下，如果按键松开而引脚悬空，这将导致引脚的状态不确定（可能会感应到噪声）。
 * 因此，为了使 GPIO 引脚的输入状态在按键松开时是已知的（低电平），我们需要配置一个下拉电阻（接地）。
 *
 * GPIO 输入模式支持以下几种类型：
 *    浮空输入模式：输入引脚没有内部上拉或下拉电阻。当引脚悬空时，电平状态不确定，容易受到噪声干扰。
 *    上拉输入模式：引脚内部连接一个上拉电阻，当引脚悬空时默认输入高电平。
 *    下拉输入模式：引脚内部连接一个下拉电阻，当引脚悬空时默认输入低电平。
 *
 * 这里我们选择下拉电阻是因为：
 *    稳定状态：在按键松开时，Pin10 引脚是悬空的。如果没有下拉电阻，输入引脚将处于浮动状态，无法确定是高还是低电平（可能感应到随机噪声）。
 *    通过配置下拉电阻，当按键松开时，Pin10 引脚被拉到低电平（0V），避免了浮空状态。
 *    正确的中断触发方式：按下按键时，引脚从低电平（下拉状态）变为高电平（输入3.3V），这会产生一个上升沿。
 *    为了检测按键按下动作，可以配置引脚在上升沿触发中断。
 *    同理在按键松开后由于内接下拉电阻，引脚会从高电平（3.3V）变为低电平（0V）产生一个下降沿，也可以用这个下降沿配置触发中断。
 *
 * 在配置 GPIO 引脚中断时，选择上升沿还是下降沿触发取决于你的具体应用需求。以下是两种触发方式的优缺点比较：

   1. 上升沿触发中断
      优点：
      适用于按键按下事件的检测：在按键按下的瞬间，电平从低（0V）变为高（3.3V），产生上升沿中断。大多数情况下，检测按键按下的事件比松开的事件更有用，因为按下操作往往是用户的意图动作。
      按键抖动的影响更小：按键按下时，通常由于机械抖动会导致电平快速来回变化几次，但通常会在电平变为高电平后停止。适当的去抖动设计可以有效过滤掉抖动。

      缺点：
      可能需要去抖动处理：按键按下时，可能会产生机械抖动，需要添加软件或硬件（加电容）去抖动逻辑来避免多个不必要的中断触发。

   2. 下降沿触发中断
      优点：
      适用于按键松开事件的检测：在按键松开的瞬间，电平从高（3.3V）变为低（0V），产生下降沿中断。如果你的应用需要检测用户松开按键的事件，这种方式更合适。
      按键松开后的电平较稳定：在按键松开后，电平通常稳定地回到低电平状态，下拉电阻会有效避免浮动状态。相对来说，松开时的抖动情况要比按下时少一些。

      缺点：
      反应时间较慢：通常情况下，按键按下事件的反应时间比松开事件更短。因为按下时是用户主动的操作，而松开可能会存在一定的滞后性。
      逻辑上的不直观：在大多数应用场景中，通常需要检测按下动作，而不是松开动作，所以上升沿会更符合直觉。

   3. 哪一个更好？
      如果你的应用主要是响应用户的按下操作，例如：按钮按下即开始一个动作，那么选择上升沿触发中断会更好。
      如果你的应用需要响应用户的松开操作，例如：按钮按下时可以进行调整，松开后再确定，那么选择下降沿触发中断更合适。

   去抖动设计
   无论选择上升沿还是下降沿中断触发，按键的去抖动处理都是非常重要的。在处理按键输入时，常用的去抖动方式有以下几种：

      软件去抖动：在中断触发后，使用定时器或延迟（如 HAL_Delay），判断在一定时间间隔内引脚电平是否稳定。

      硬件去抖动：在按键电路中添加 RC 低通滤波器或使用专用的去抖动芯片。
 *
 *
 * GPIO 中断可以通过 EXTI（外部中断/事件控制器）模块配置成上升沿、下降沿或双边沿触发中断。
 * 根据按键的电路，我们选择 上升沿触发：
 * 上升沿触发：当按键按下时，GPIOF Pin10 从低电平（0V）变为高电平（3.3V），这是一个上升沿变化，从而触发中断。
 * 下降沿触发：如果按键松开时我们需要触发中断，那就会用到下降沿触发；但此处我们只关心按下动作。
 *
 */
void Driver_Key_Init(void)
{
   /* 1. 开启时钟 */
   /* 1.1  GPIOF*/
   RCC->APB2ENR |= RCC_APB2ENR_IOPFEN;
   /* 1.2  AFIO*/
   RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;

   /* 2. 配置 PF10为下拉输入: MODE=00 CNF=10  ODR=0 */
   GPIOF->CRH &= ~GPIO_CRH_MODE10;
   GPIOF->CRH |= GPIO_CRH_CNF10_1;
   GPIOF->CRH &= ~GPIO_CRH_CNF10_0;
   GPIOF->ODR &= ~GPIO_ODR_ODR10;

   /* 3. 配置AFIO 配置PF10引脚为外部中断  EXTICR3  0101*/
   AFIO->EXTICR[2] &= ~AFIO_EXTICR3_EXTI10;
   AFIO->EXTICR[2] |= AFIO_EXTICR3_EXTI10_PF;

   /* 4. 配置EXTI */
   /* 4.1. 配置上升沿触发 RTSR TR10=1*/
   EXTI->RTSR |= EXTI_RTSR_TR10;
   /* 4.2 开启 LINE10, 配置的中断屏蔽寄存器 */
   /*
   MRx: Interrupt Mask on line x
   0: Interrupt request from Line x is masked（被屏蔽）
   1: Interrupt request from Line x is not masked
   */
   EXTI->IMR |= EXTI_IMR_MR10;

   /* 5. 配置 NVIC */
   /* 5.1 配置优先级组 (3-7) 配置3表示4个二进制位全部用于表示抢占优先级*/
   NVIC_SetPriorityGrouping(3);
   /* 5.2 配置优先级 参数1:中断号*/
   NVIC_SetPriority(EXTI15_10_IRQn, 3);
   /* 5.3 使能Line10 */
   NVIC_EnableIRQ(EXTI15_10_IRQn);
}

/**
 * @description: line 15-10的中断服务函数.
 *  一旦按键下按键1,则会执行一次这个函数
 * @return {*}
 */
uint8_t isKeypressed = 0;  // 按键是否按下
void EXTI15_10_IRQHandler(void)
{
   /* 当 Edge detect circuit 检测到上升沿或者下降沿产生中断后，在没有屏蔽这个中断的情况下，硬件会自动将中断挂起位置为1
      NVIC是通过读取这个中断挂起标志位来处理中断的，在进入中断服务函数后说明中断被执行，而挂起位不会自动清除，务必一定必须要清除中断标志位 */
   EXTI->PR |= EXTI_PR_PR10;

   delay_ms(7);
   if ((GPIOF->IDR & GPIO_IDR_IDR10) != 0)
   {
      isKeypressed = 1; // 按键按下
   }
}
/*
使用key1控制灯的动作
*/
